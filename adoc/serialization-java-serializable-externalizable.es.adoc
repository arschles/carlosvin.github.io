= Distintas formas de serialización en Java: Comparación de rendimiento
2014/05/13 17:00:00
:keywords: Java

:toc:

[abstract]
== Abstract
Comparación de rendimientos entre distintas formas de serialización en Java

Hace poco, he tenido que serializar/deserializar unos datos en link:[Java], hacía mucho que no lo hacía en formato binario directamente (ultimamente he utilizado link:[JSON] o link:[XML]). Recordaba haber serializado objetos implementando el interfaz link:#serializable[Serializable], pero había visto por Internet otra forma implementando el interfaz link:#externalizable[Externalizable], ¿cuál interfaz utilizo? Pues depende lo que quieras y necesites, como todo.

Cuándo utilizar Serializable o Externalizable

== link:#serializable[Serializable]

* Cuando quieras serializar algo programando poco, es la forma fácil.
* Pero tiene algunas restricciones: El objeto a serializar debe implementar el constructor por defecto. Debe hacerse responsable de los atributos no accesibles de la clase padre.
* Cuando no te importe mucho el rendimiento, como veremos en la sección link:#pruebas-de-rendimiento-serializable-vs-externalizable[Pruebas de Rendimiento (Serializable vs Externalizable)].

== link:#externalizable[Externalizable]

* Vas a tener que implementar tú mismo los métodos de serialización.
* Cuando no puedas utilizar link:#serializable[Serializable].
* Cuando quieras obtener un mejor rendimiento, como veremos en la sección link:#pruebas-de-rendimiento-serializable-vs-externalizable[Pruebas de Rendimiento (Serializable vs Externalizable)]
* Si tienes que encargarte de la serialización de los atributos de la clase padre, te recomiendo utilizar link:#externalizable[Externalizable], porque evitamos una sobrescritura extraña de métodos privados.

[source,java]
----
private void writeObject(ObjectOutputStream oos)
private void readObject(ObjectInputStream ois)
----

== Pruebas de Rendimiento (Serializable vs Externalizable)

El interfaz link:#serializable[Serializable] utilizando la introspección de link:[Java], adivina los tipos de los atributos de las clases que va a serializar/deserializar, pero esta "magia" tiene una penalización en el rendimiento.

Al utilizar el interfaz link:#externalizable[Externalizable] somos nosotros los que decidimos como serializar/deserializar los objetos, es decir, tenemos que escribir nosotros el código que hace esto. Hemos perdido comodidad, pero evitamos que link:[Java] haga algunas tareas y, si sobrescribimos correctamente los métodos del interfaz link:#externalizable[Externalizable], conseguiremos una mejora de rendimiento.

Para saber cuánto es la diferencia de rendimiento, he escrito un [.title-ref]#pequeño ejemplo en el que se serializa un objeto con dos colecciones con 100000 emails y 100000 teléfonos#. He contemplado 3 casos:

=== Utilizando el interfaz link:#serializable[Serializable]

Como dijimos más arriba, utilizando el interfaz link:#serializable[Serializable] link:[Java] tiene que adivinar ciertas cosas, en este proceso sacrifica algo de rendimiento (es el que más tarda), a cambio ĺo único que tenemos que hacer es que nuestra clase implemente el interfaz link:#serializable[Serializable].

[source,java]
----
public class Contacts implements Serializable {
----

* 1133 milisegundos en serializar
* 506 milisegundos en deserializar

=== Utilizando el interfaz link:#externalizable[Externalizable] (mal)

En este caso somos nosotros los encargados de "decir" a link:[Java] cómo debe serializar/deserializar, pero debemos ser cuidadosos, de lo contrario podemos quedarnos con lo peor de los dos mundos, por ejemplo: Si simplemente serializamos/deserializamos los atributos de la clase, y estos son atributos complejos (como colecciones), link:[Java] también tiene que adivinar bastantes cosas y también sacrificamos algo de rendimiento y además hemos tenido que escribir más código.

[source,java]
----
@Override
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  setEmails((Set<String>) in.readObject());
  setPhones((Set<String>) in.readObject());
}

@Override
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeObject(emails);
  out.writeObject(phones);
}
----

* 737 milisegundos en serializar
* 367 milisegundos en deserializar

=== Utilizando el interfaz link:#externalizable[Externalizable] (bien)

Si serializamos/deserializamos uno por uno los elementos de las colecciones, ahorramos aún más tiempo, porque link:[Java] está serializando tipos más simples (en este caso java.lang.String).

[source,java]
----
@Override
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  emails.clear();
  phones.clear();
  int nEmails = in.readInt();
  for (int i = 0; i < nEmails; i++) {
    emails.add(in.readUTF());
  }
  int nPhones = in.readInt();
  for (int i = 0; i < nPhones; i++) {
    phones.add(in.readUTF());
  }
}

@Override
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(emails.size());
  for (String e : emails) {
    out.writeUTF(e);
  }
  out.writeInt(phones.size());
  for (String p : phones) {
    out.writeUTF(p);
  }
}
----

* 204 milisegundos en serializar
* 92 milisegundos en deserializar

Hemos ganado rendimiento a costa de escribir un poco más de código.

=== Analizando los resultados

[CAUTION]
.Caution
====
Por el hecho de utilizar un interfaz u otro, no ganamos rendimiento.
====[TIP]
.Tip
====
Ganamos rendimiento porque el interfaz link:#externalizable[Externalizable] nos "obliga" a implementar parte de la serialización y quitamos esta carga a link:[Java].
====Aunque como hemos visto en link:#utilizando-el-interfaz-externalizable-bien[Utilizando el interfaz Externalizable (bien)], si no tenemos cuidado, conseguiremos una mejora muy pequeña.

A continuación podéis ver un link:[gráfico] con los resultados de los tests.

image:https://docs.google.com/spreadsheets/d/1V9p6shPMpSr7RcaTruXpj_0ZQUpVjMFdeh7AnObaBL8/embed/oimg?id=1V9p6shPMpSr7RcaTruXpj_0ZQUpVjMFdeh7AnObaBL8&oid=2110613848&zx=t87gu6ve3lan[Abrir el link:[gráfico] interactivo | link:[Abrir imagen],scaledwidth=80.0%]

A continuación os dejo los enlaces a:

* https://carlosvin.github.io/serializations-performance-java/reports/tests/classes/com.diky.contacts.SerializationTest.html[Resultados de los tests].
* https://github.com/carlosvin/serializations-performance-java/[Código en github].
* Estado de la link:[Construcción en travis]
+
image:https://travis-ci.org/carlosvin/serializations-performance-java.svg?branch=master[image]

_Java::
  https://www.java.com/
_JSON::
  https://www.json.org/
_XML::
  https://en.wikipedia.org/wiki/XML
_Serializable::
  https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html
_Externalizable::
  https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html
